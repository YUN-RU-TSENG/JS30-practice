# 小筆記：JS15
###### tags: `javascript`


## 關鍵要點
* local storage ｜ session storage | cookies 三者的差異以及一般使用的情境。


## 步驟分解
###

## 基礎語法

### cookie

#### 語法
```javascript=
// Create
document.cookie = "user_name=Ire Aderinokun";  
document.cookie = "user_age=25;max-age=31536000;secure";

// Read (All)
console.log( document.cookie );

// Update
document.cookie = "user_age=24;max-age=31536000;secure"; 

// Delete
document.cookie = "user_name=Ire Aderinokun;expires=Thu, 01 Jan 1970 00:00:01 GMT";
```

---

### local storage


```javascript=
// Create
const user = { name: 'Ire Aderinokun', age: 25 }  
localStorage.setItem('user', JSON.stringify(user));

// Read (Single)
console.log( JSON.parse(localStorage.getItem('user')) ) 

// Update
const updatedUser = { name: 'Ire Aderinokun', age: 24 }  
localStorage.setItem('user', JSON.stringify(updatedUser));

// Delete
localStorage.removeItem('user');  
```

---

### session storage

```javascript=
// Create
const user = { name: 'Ire Aderinokun', age: 25 }  
sessionStorage.setItem('user', JSON.stringify(user));

// Read (Single)
console.log( JSON.parse(sessionStorage.getItem('user')) ) 

// Update
const updatedUser = { name: 'Ire Aderinokun', age: 24 }  
sessionStorage.setItem('user', JSON.stringify(updatedUser));

// Delete
sessionStorage.removeItem('user');
```

---

### local storage ｜ session storage | cookies 三者的語法

![](https://i.imgur.com/hMfaLzm.png)

![](https://i.imgur.com/ObymOU1.png)

> 出處 [[译]客户端(浏览器端)数据存储技术概览
](https://github.com/dwqs/blog/issues/42)

---

### indexDB

IndexedDB 是面向 JS 的，面向對象和數據庫。
存入的方式比其他都還要來得複雜。

---

## Alex 筆記

* 資料庫的概念，除了後端之外也可以使用一些前端的方式達成。
* 有說到可以用這個破解人家的網站，可以之後去查。
>![](https://i.imgur.com/6z8JkVq.jpg)
* 使用 network 觀看他人的網路活動（加載過程）。[google](https://developers.google.com/web/tools/chrome-devtools/network)
> ![](https://i.imgur.com/b6pfwEO.png)
![](https://i.imgur.com/2e0KZnq.png)

* storage = 存儲
* cookie 網頁加載入時，會跑出的警告視窗，通常除非用戶不同意，否則都會被網頁使用。
* local storage 比起 session storage 來說，是可以永久存取，所以 session storage 只要瀏覽器關掉，他就會被關掉。
* indexDB 蠻適合前端來學習類似 SQL 的概念，不用真的去建立一個資料庫。
* web SQL ？
* 每做一次更新，都要重新去更動、請求 local storage
* ==copy 別人的 fun 時，謹記改寫變數、名稱等等方式，幫助自己理解==（前提是你真的需要 copy，沒事請自己寫）
* 寫的時候要注意三元運算子、`||`
> ![](https://i.imgur.com/V5AMPWS.png)



---

## 什麼是 cookie？
[Mozilla](https://support.mozilla.org/zh-TW/kb/cookies-information-websites-store-on-your-computer#w_kajkog-cookieska)

:::info
Huli
1. [白話 Session 與 Cookie：從經營雜貨店開始](https://medium.com/@hulitw/session-and-cookie-15e47ed838bc) 
2. [淺談 Session 與 Cookie：一起來讀 RFC](https://github.com/aszx87410/blog/issues/45) 
3. [深入 Session 與 Cookie：Express、PHP 與 Rails 的實作](https://github.com/aszx87410/blog/issues/46) 

---

## 回到最開始的問題：到底 Session 是什麼？

從 RFC 裡面提到的各種 Session 相關的字眼，我會認為 Session 就是它英文的原意之一，代表著：「具有狀態的一段期間」或者是「上下文」，所以你想要開啟或是建立一個 Session，必要條件就是先有一個機制來建立及保留狀態。
這也是為什麼 Cookie 的 RFC 標題為：HTTP State Management Mechanism，狀態管理機制。在 Cookie 還沒出現以前，一樣可以建立 Session，可以把狀態資訊放在網址列上面或是藏在 form 表單中。但 Cookie 出現以後建立 Session 變成一件更容易的事，只要使用 Set-Cookie 與 Cookie 這兩個 header 就好了。
建立 Session 之後，所儲存的狀態就叫做 Session information，可以翻作 Session 資訊。若是選擇把這些資訊存在 Cookie 裡面，就叫做 Cookie-based session；還有另一種方法則是在 Cookie 裡面只存一個 SessionID，其他的 Session 資訊都存在 Server 端，靠著這個 ID 把兩者關聯起來。
除了 Session 以外，我們也在 RFC 裡面看見一些有趣的東西，例如說第三方 Cookie 的隱私疑慮以及與 Cookie 相關的安全性問題。這些也能加深你對於 Cookie 的理解。
在結束以前，我誠心推薦一篇文章： [HTTP Cookies: Standards, Privacy, and Politics](https://arxiv.org/abs/cs/0105018) ，網頁右邊可以下載 PDF 來看。這篇文章的作者就是 RFC 2109 與 2965 的作者。文章裡面把 Cookie 出現的歷史以及當初發生的事講的一清二楚，強烈建議大家都可以花點時間來看這篇文章，可以深入地理解 Cookie 與 Session 早期的歷史。
最後，別忘了這是系列文的第二篇，下一篇我們會來看一些主流框架如何處理 Session。

:::

Cookies 曾被當作一般的客戶端儲存方式來使用。這在當時 cookie 仍是將資料儲存在客戶端的唯一方法時是合法的，現在則建議使用現代的 storage APIs。Cookies 會被每一個請求發送出去，所以可能會影響效能（尤其是行動裝置的資料連線）。==現代客戶端的 storage APIs 為 Web storage API （localStorage 和 sessionStorage）以及 IndexedDB==。

Cookies 是網站在您瀏覽網頁時儲存在您的電腦上的資料。

在某些瀏覽器，每個 cookies 都是一個小檔案，但是 Firefox 的 cookies 全數存成一個檔案放在 Firefox 使用者設定檔資料夾。

通常儲存瀏覽該網站時的各種偏好設定，例如您的偏好語言與位置。日後再瀏覽該網站時 Firefox 會回傳屬於該網站的 cookies 資訊，這樣網站就可以提供符合您需求的資訊。

Cookies 可用於儲存各種資訊，包含個人識別資訊（例如姓名、電子信箱、家中與公司電話住址……等等）。不過網站所能儲存使用的資料，也只有您確實輸入過的內容。網站無法自行取得您沒有提供過的資料，也不能任意存取您電腦內的檔案。

![](https://i.imgur.com/XpNIE1w.png)
:::danger
從這裡得知也可以使用在 https 就不會有安全性問題，但是要如何使用 https 傳輸 cookis 又是 ？？？
:::

* 什麼是 cookie [維基百科](https://zh.wikipedia.org/wiki/Cookie)

預設狀況下會自動儲存與傳送 cookies，您也不會察覺。但您也可以設定 Firefox 去允許或拒絕 Cookie 儲存、或者在離開 Firefox 時自動清除所有的 cookies……等。

==Cookie總是儲存在客戶端中，按在客戶端中的儲存位置，可分為記憶體Cookie和硬碟Cookie。==

==記憶體Cookie由瀏覽器維護，儲存在記憶體中，瀏覽器關閉後就消失了，其存在時間是短暫的==。==硬碟Cookie儲存在硬碟裡，有一個過期時間，除非用戶手動清理或到了過期時間，硬碟Cookie不會被刪除，其存在時間是長期的==。所以，按存在時間，可分為非持久Cookie和持久Cookie。

*Cookie*（複數形態Cookies），又稱為「小甜餅」。類型為「*小型文字檔案*」 [[1]](https://zh.wikipedia.org/wiki/Cookiecite_note-1) ，指某些 [網站](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99) 為了辨別用戶身分而儲存在用戶端（Client Side）上的資料（通常經過 [加密](https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86) ）。由 [網景公司](https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8) 的前雇員 [盧·蒙特利](https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9) 在1993年3月發明 [[2]](https://zh.wikipedia.org/wiki/Cookie#cite_note-2) 。最初定義於RFC 2109。目前使用最廣泛的 Cookie標準卻不是RFC中定義的任何一個，而是在網景公司制定的標準上進行擴充後的產物。

#### 刪除 cookie

##### expires, max-age

* https://javascript.info/cookie

```javascript=
// +1 day from now
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=John; expires=" + date;
```

```javascript=
// cookie will die +1 hour from now
document.cookie = "user=John; max-age=3600";

// delete cookie (let it expire right now)
document.cookie = "user=John; max-age=0";
```

:::info
* 5.2.2.  The Max-Age Attribute



   If the attribute-name case-insensitively matches the string "Max-
   Age", the user agent MUST process the cookie-av as follows.

   If the first character of the attribute-value is not a DIGIT or a "-"
   character, ignore the cookie-av.

   If the remainder of attribute-value contains a non-DIGIT character,
   ignore the cookie-av.

   Let delta-seconds be the attribute-value converted to an integer.

   If delta-seconds is less than or equal to zero (0), let expiry-time
   be the earliest representable date and time.  Otherwise, let the
   expiry-time be the current date and time plus delta-seconds seconds.

   Append an attribute to the cookie-attribute-list with an attribute-
   name of Max-Age and an attribute-value of expiry-time.
:::

:::info
* 5.2.1.  The Expires Attribute

有效期限，單位是秒；當數值為正數時有效，負數時為本次 Session 有效；0 為刪除 Cookie

   If the attribute-name case-insensitively matches the string
   "Expires", the user agent MUST process the cookie-av as follows.

   Let the expiry-time be the result of parsing the attribute-value as
   cookie-date (see Section 5.1.1).

   If the attribute-value failed to parse as a cookie date, ignore the
   cookie-av.

   If the expiry-time is later than the last date the user agent can
   represent, the user agent MAY replace the expiry-time with the last
   representable date.
   
   ![](https://i.imgur.com/rFeYUQB.png)

   
* https://tools.ietf.org/html/rfc6265#page-19
:::

### set cookie

[set-cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)
* https://tools.ietf.org/html/rfc6265#section-4.1

![](https://i.imgur.com/LJO6F6l.png)

:::danger
不瞭解從何處設定？
:::

* https://medium.com/schaoss-blog/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%8D%81-27-web-cookie-session-%E6%98%AF%E4%BB%80%E9%BA%BC-83f9747caf23


### HTTP 超文本傳輸協定
[維基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)

*超文本傳輸協定*（英語：*H*yper*T*ext*T*ransfer*P*rotocol，縮寫：*HTTP*）是一種用於分佈式、協作式和 [超媒體](https://zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94) 訊息系統的 [應用層](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82)  [協定](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)  [[1]](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#cite_note-ietf2616-1) 。HTTP是 [全球資訊網](https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2) 的資料通信的基礎。
設計HTTP最初的目的是為了提供一種發布和接收 [HTML](https://zh.wikipedia.org/wiki/HTML) 頁面的方法。透過HTTP或者 [HTTPS](https://zh.wikipedia.org/wiki/HTTPS) 協定請求的資源由 [統一資源識別碼](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6) （Uniform Resource Identifiers，URI）來標識。
HTTP的發展是由 [提姆·柏內茲-李](https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E) 於1989年在 [歐洲核子研究組織](https://zh.wikipedia.org/wiki/%E6%AD%90%E6%B4%B2%E6%A0%B8%E5%AD%90%E7%A0%94%E7%A9%B6%E7%B5%84%E7%B9%94) （CERN）所發起。HTTP的標準制定由 [全球資訊網協會](https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F) （World Wide Web Consortium，W3C）和 [網際網路工程任務組](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84) （Internet Engineering Task Force，IETF）進行協調，最終發布了一系列的 [RFC](https://zh.wikipedia.org/wiki/RFC) ，其中最著名的是1999年6月公布的 [RFC 2616](https://tools.ietf.org/html/rfc2616) ，定義了HTTP協定中現今廣泛使用的一個版本——HTTP 1.1。

[規範 RFC1945](https://tools.ietf.org/html/rfc1945)

==HTTP是一個客戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用TCP協定。透過使用網頁瀏覽器、網路爬蟲或者其它的工具，客戶端發起一個HTTP請求到伺服器上指定埠（預設埠為80）。我們稱這個客戶端為用戶代理程式（user agent）。應答的伺服器上儲存著一些資源，比如HTML檔案和圖像==。我們稱這個應答伺服器為源伺服器（origin server）。在用戶代理和源伺服器中間可能存在多個「中間層」，比如代理伺服器、閘道器或者隧道（tunnel）。

儘管TCP/IP協定是網際網路上最流行的應用，但是在HTTP協定中並沒有規定它必須使用或它支援的層。事實上HTTP可以在任何網際網路協定或其他網路上實作。HTTP假定其下層協定提供可靠的傳輸。因此，任何能夠提供這種保證的協定都可以被其使用，所以其在TCP/IP協定族使用TCP作為其傳輸層。


### TCP 傳輸控制協定

[維基百科](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)

傳輸控制協定（英語：Transmission Control Protocol，縮寫：TCP）是一種連接導向的、可靠的、基於位元組流的傳輸層通信協定，由IETF的RFC 793定義。在簡化的電腦網路OSI模型中，它完成第四層傳輸層所指定的功能。用戶資料報協定（UDP）是同一層內另一個重要的傳輸協定。

==TCP協定的執行可劃分為三個階段：連接建立(connection establishment)、資料傳送（data transfer）和連接終止（connection termination）==。作業系統將TCP連接抽象為通訊端表示的本地端點（local end-point），作為編程介面給程式使用。在TCP連接的生命期內，本地端點要經歷一系列的狀態改變。

### 網際網路協定 IP

[維基百科](https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE)

IP是在TCP/IP協定套組中網路層的主要協定，任務僅僅是根據源主機和目的主機的位址來傳送資料。為此目的，IP定義了尋址方法和資料報的==封裝結構==。第一個架構的主要版本為IPv4，目前仍然是廣泛使用的網際網路協定，儘管世界各地正在積極部署IPv6。

### 網際網路協議 TCP/IP

[維基百科](https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F)

網際網路協議（英語：Internet Protocol Suite，縮寫IPS）[1]是一個網路通訊模型，以及一整個網路傳輸協定家族，為網際網路的基礎通訊架構。==它常被通稱為TCP/IP協定套組（英語：TCP/IP Protocol Suite，或TCP/IP Protocols），簡稱TCP/IP[2]。因為該協定家族的兩個核心協定：TCP（傳輸控制協定）和IP（網際網路協定），為該家族中最早通過的標準[3]==。由於在網路通訊協定普遍採用分層的結構，當多個層次的協定共同工作時，類似電腦科學中的堆疊，因此又被稱為TCP/IP協定疊（英語：TCP/IP Protocol Stack）[4][5] 。這些協定最早發源於美國國防部（縮寫為DoD）的ARPA網專案，因此也被稱作DoD模型（DoD Model）[6]。==這個協定套組由網際網路工程任務組負責維護==。

==TCP/IP提供了點對點連結的機制，將資料應該如何封裝、定址、傳輸、路由以及在目的地如何接收，都加以標準化==。它將軟體通訊過程抽象化為四個抽象層，採取協定堆疊的方式，分別實作出不同通訊協定。協定套組下的各種協定，依其功能不同，被分別歸屬到這四個階層之中[7][8]，常被視為是簡化的七層OSI模型。

### HTTPS

超文本傳輸安全協定（英語：HyperText Transfer Protocol Secure，縮寫：HTTPS；常稱為HTTP over TLS、HTTP over SSL或HTTP Secure）是一種透過計算機網路進行安全通訊的傳輸協定。==HTTPS經由HTTP進行通訊，但利用SSL/TLS來加密封包==。==HTTPS開發的主要目的，是提供對網站伺服器的身分認證，保護交換資料的隱私與完整性==。這個協定由網景公司（Netscape）在1994年首次提出，隨後擴展到網際網路上。

---

> 出處 https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API
出處：使用瀏覽器更改 cookie https://developers.google.com/web/tools/chrome-devtools/storage/cookies?utm_source=devtools

![](https://i.imgur.com/iRLc8rY.png)

---


### json.stringify json.parse

用JSON.stringify把物件轉成字串，再用JSON.parse把字串轉成新的物件。

---

## 迷惑行為大賞
* Cookie會被附加在每個HTTP請求中，所以無形中增加了流量。 ==http請求是？==
* 由於在HTTP請求中的Cookie是明文傳遞的，所以安全性成問題，除非用HTTPS。==http、https 差異==
* indexDB、web SQL ?
* innerHTML、contentText、createElement 差異？誰會加到 DOM tree 上。